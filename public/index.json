[{"content":"Introduction In the previous article, we talked about creating a project with Karate and created a small test. Now, let\u0026rsquo;s try to create some more detailed test examples.\nTesting For our first example, let\u0026rsquo;s look at API examples on GitHub. On the opened page, under the Public APIs heading, we can click on the Animals option or scroll down to reach the same heading.\nI selected the IUCN Red List of Threatened Species example from the Animals API examples. You can also continue with a different example. When we click the link, we get examples for the International Union for Conservation of Nature Red List of Threatened Species.\nFor our first example, let\u0026rsquo;s open our project in the IntelliJ application again.\nFirst, let\u0026rsquo;s call the service that lists the isocodes of countries. We specify the URL information of the address we need to go to http://apiv3.iucnredlist.org/api/v3/country/list?token='YOUR-TOKEN' in the background. In Karate tests, the background is the area where we use common definitions and is executed before every test.\nWe can also specify the URL information on the scenario, but it will be better to specify it in the background since we will use it in multiple scenarios.\nAfterwards, we can start defining the path we will use in our scenario.\nIn this way, we have specified the service we want to call. Before proceeding, we can run our test once to check if the access is provided.\nWe can see from the test result that access to the specified address is provided.\nThe service address we want to access was http://apiv3.iucnredlist.org/api/v3/country/list?token='YOUR-TOKEN'. Here, the token definition that comes after the question mark is the parameter value expected by the service. Parameter information in Karate scenarios is specified as shown below.\nAfterwards, we complete our test steps by specifying our method and the status we expect, and by printing the response.\nWhen we run our test, we see that information for 251 countries is listed.\nHere, the results content is sent as an array. We can retrieve the desired element from this array by specifying its index number.\nBefore printing the element in the array, I printed \u0026ldquo;example\u0026rdquo; to make it easier to distinguish in the printed response. Then, to access the elements inside the array, I specified response.results and then the index number of the element I wanted to retrieve.\nIn this way, we can view the value of the element printed in the response as shown below.\nLet\u0026rsquo;s try calling a different service. Since we defined the URL in the background, we can create a different scenario by just changing the path. When we run the feature in this way, we can see that both scenarios work successfully.\nIn Karate, we can use the match command to check whether the fields returned in the response are equal to the values we want. In our second scenario, there is also a response returned as an array. Here, let\u0026rsquo;s perform a check on the response. For this, we should first access the results in the response and then the field we want to check within the array. Let\u0026rsquo;s check that the scientific name value of the fourth element in the array is equal to \u0026ldquo;Abies nordmanniana\u0026rdquo;.\nIn this way, we can ensure the control of the field returned in the response. If we write something different on the right side, we can also see this in our test result.\nWhen we run the test after making the change, we can see that the value we expect and the value returned in the response are not equal.\nLet\u0026rsquo;s continue with the post method.\nIn Karate, we can specify our requests within the scenario steps or call them from outside. If we want to call it within the scenario step, we can write it as shown below.\nHowever, I prefer to call my request from outside because specifying it within the test step can make it difficult to track when there are too many fields in the request.\nTo call our request from outside, we need to create a separate file first. We can do this by right-clicking on the folder where our feature file is located and following the New-\u0026gt; File step. Since we use JSON in our tests, we create our request file with the \u0026lsquo;.json\u0026rsquo; extension.\nAfter creating my request in this way, I need to call this request within my test. I do this with the read command.\nThen, by specifying my method and the status I expect, and by printing the response, I complete my test.\nAfter running our test, we can see our result as shown below.\nIf we want to make changes to the request file we use, we can use the set command. After setting it up in this way, we can print our new request and see it.\nWhen we run our test, we can see both our request and our response.\nRequest:\nResponse:\nWe did not make any changes to the content of our user.json file while doing this. With the set command, we can also make dynamic changes to our request.\nI hope my article, where I mentioned the basic steps of web service testing with Karate, will be useful to the readers. üòä\nSOURCES\nhttps://github.com/public-apis/public-apis?source=post_page-----d606862d38a9-------------------------------- https://reqres.in/?source=post_page-----d606862d38a9-------------------------------- Medium\n","permalink":"http://localhost:1313/blog/more-testing-with-karate/","summary":"Introduction In the previous article, we talked about creating a project with Karate and created a small test. Now, let\u0026rsquo;s try to create some more detailed test examples.\nTesting For our first example, let\u0026rsquo;s look at API examples on GitHub. On the opened page, under the Public APIs heading, we can click on the Animals option or scroll down to reach the same heading.\nI selected the IUCN Red List of Threatened Species example from the Animals API examples.","title":"Web Service Testing with Karate DSL"},{"content":"Introduction Hello everyone, in this article, I will talk about the use of Karate. And no it\u0026rsquo;s NOT THE Karate. üòÖ\nFirst, let\u0026rsquo;s briefly introduce Karate. Karate is an open-source test tool created by Peter Thomas in 2017. With Karate, it is possible to perform manual testing, automation testing, and performance testing.\nWe can list its basic features as follows:\nYou do not need to know any programming language to use the Karate tool. Tests are created using the Gherkin language with BDD syntax. Writing and reading tests is easy. JSON, XML, and HTTP formats can be used. It is possible to access different test environments from the same script.\nCREATING A PROJECT Now let\u0026rsquo;s create our first project with Karate. First, we open our IntelliJ application. We click on the new project button.\nAfterwards, the following screen will appear. Here we need to select the \u0026lsquo;Create from archetype\u0026rsquo; option.\nAfter selecting this option, the \u0026lsquo;Add Archetype\u0026rsquo; button will become active. We click this button and fill in the necessary fields as shown below.\nAs we proceed, the previous screen will appear again, and the archetype we created will be visible in the list. We select the archetype and move on to the next step.\nNext, we need to name our project. I chose to name it firstProject. You can name it as you wish and continue.\nIn the next step, you can proceed by selecting as shown below without making any changes.\nWhen we click the finish button, our project will appear as shown below.\nAfter the project is created, we can see logs indicating that the Maven libraries have been installed in the terminal. At this step, it should say BUILD SUCCESS as shown below. Otherwise, not all libraries would have been installed, and we would encounter errors in our project.\nHere, we also have a sample feature file that we can see as an example.\nWe can see the sample scenarios inside this file.\nCREATING A TEST Yes, we have created our first project. Now we can start writing our tests in our feature file. For this, we can create a new test folder or continue with the existing one. I will continue with the existing folder. Let\u0026rsquo;s right-click on the Java folder. Select New-\u0026gt;Package.\nRight-click on the new folder we created and select New-\u0026gt;File.\nIn the Gherkin language, test files are named as feature. Therefore, we should name our test file with the \u0026lsquo;.feature\u0026rsquo; extension.\nAfter defining our test file, a blank page will appear.\nThe features of the scenarios we will test should be defined in the feature file. I preferred to define the feature in the same way as the file name (basicTest.feature), but it can also be defined differently according to the scenarios.\nNext, let\u0026rsquo;s name our test scenario.\nAfter naming our scenario, we can move on to our steps. But first, let\u0026rsquo;s talk about some keywords used in the test steps and how they are used.\nGiven: The step where the necessary condition to start our scenario is specified. When: The step where the action to be taken is specified. Then: The step where the event that will happen after the action is taken is defined. And: The keyword used when there is more than one step.\nAs shown below, we created our first scenario. We specified the address we want to go to, the method we will use, the status response we want to see, and then added the step to print our response.\nTo run the test, we can right-click on the scenario and select run, or we can click the green arrow on the left to run the test.\nAfter running the test, the response can be viewed as shown below.\nAll test results will be displayed under the printed response as shown below.\nIn this way, we briefly talked about Karate and its usage. I hope this article will be useful to the readers.\nSOURCES\nhttps://www.youtube.com/watch?v=-KOJ12Dbxrk https://en.wikipedia.org/wiki/Karate_(software) https://en.wikipedia.org/wiki/Behavior-driven_development Medium\n","permalink":"http://localhost:1313/blog/what-is-karate-testing/","summary":"Introduction Hello everyone, in this article, I will talk about the use of Karate. And no it\u0026rsquo;s NOT THE Karate. üòÖ\nFirst, let\u0026rsquo;s briefly introduce Karate. Karate is an open-source test tool created by Peter Thomas in 2017. With Karate, it is possible to perform manual testing, automation testing, and performance testing.\nWe can list its basic features as follows:\nYou do not need to know any programming language to use the Karate tool.","title":"What is Karate DSL? How to Create a Project and Perform Web Service Testing?"},{"content":"What is a Web Service? The most basic definition of a web service is the standard protocols (HTTP or HTTPS) used for communication between systems. This communication is mostly centered around XML and JSON.\nBriefly, XML (Extensible Markup Language) is a language that enables the creation of easily readable documents, known in Turkish as Geni≈ületilebilir ƒ∞≈üaretleme Dili.\nJSON (JavaScript Object Notation), which translates to JavaScript Nesne Notasyonu in Turkish, is a more flexible language compared to XML. It is also one of the languages used for data communication.\nApplications and systems written in different programming languages and running on various platforms communicate through JSON or XML, making them independent of any operating system or programming language.\nWeb services can be examined under the SOAP and REST architectures. Let\u0026rsquo;s briefly touch on these concepts.\nSOAP: Standing for Simple Object Access Protocol, SOAP is a service protocol that primarily uses the HTTP protocol for communication. It communicates exclusively through XML and is not flexible in this regard.\nAlthough it only supports communication through XML, security controls are easier within SOAP, making it more frequently used when such controls are necessary.\nREST: Standing for Representational State Transfer, REST is an architecture that also uses the HTTP protocol for communication. However, unlike SOAP, it does not mandate the use of XML. It allows communication using JSON, HTML, or even plain text. This flexibility makes it more preferred.\nThe amount of data transferred within REST is smaller, making it ideal for applications requiring high performance.\nWeb Service Testing Web service tests hold a significant place among test types and are conducted to check the functionality, performance, and reliability of an application or system. To ensure systems work successfully and data flow is correctly provided, it is necessary to test the web services that supply data to the user interface.\nThe general working principle of web service tests is the same. The client sends a request, and the server returns an appropriate response based on the received request. It is crucial to ensure the correctness of the fields in the sent request; otherwise, an incorrect response will be returned, leading to a misinterpretation of the test.\nWeb service tests are similar to unit tests in some aspects but differ in the following way: the development of web service tests is done in a way that supports all versions of the application. Thus, even if a new version of the application is released, regression testing can be performed for both the current and all previous versions. This situation prevents an increase in test time during the development of new parts of the product and ensures usability in older versions of the product without needing changes.\nThere are many tools available for conducting web service testing. The most common ones are SoapUI, Postman, and JMeter. Web service tests can be performed manually with SoapUI, while Postman and JMeter are more commonly used for automating web service tests.\nIn this article, I briefly introduced web services and discussed the purposes of web service testing. See you in future articles :)\nSOURCES\nhttps://www.tutorialspoint.com/webservices/what_are_web_services.htm https://www.guru99.com/webservice-testing-beginner-guide.html Medium\n","permalink":"http://localhost:1313/blog/web-service-testing/","summary":"What is a Web Service? The most basic definition of a web service is the standard protocols (HTTP or HTTPS) used for communication between systems. This communication is mostly centered around XML and JSON.\nBriefly, XML (Extensible Markup Language) is a language that enables the creation of easily readable documents, known in Turkish as Geni≈ületilebilir ƒ∞≈üaretleme Dili.\nJSON (JavaScript Object Notation), which translates to JavaScript Nesne Notasyonu in Turkish, is a more flexible language compared to XML.","title":"Web Service Testing"},{"content":"Introduction One of the most used concepts in the software world is SDLC (Software Development Life Cycle). So, what is SDLC? Briefly, it is the processes that include the development, design, and testing of a product.\nUnderstanding software development processes is as important for a test engineer as test quality, types, and test tools. In this article, I tried to briefly convey the most common SDLC processes, Agile and Waterfall modeling. :)\nAGILE MODEL The Agile model is a method that is more flexible than traditional software development models and involves the user in the software development process.\nIn the Agile model, tasks are progressed by breaking them into small pieces, aiming to bring the product to the user faster. Thanks to this flexibility in the Agile model, user change requests can be quickly responded to.\nThe team mentality prevails over the individual, emphasizing team spirit. Test and development are not seen as separate parts. The entire team is considered responsible for the quality of the development made.\nThe most common processes progressing with Agile modeling are Scrum and Kanban.\nScrum Scrum is a management model used for the management of complex software projects. Simplicity is the basis, so it is easy to understand. Scrum focuses on the product and continuously improving and developing the product. Teams consist of a small number of people.\nThe Scrum team consists of a product owner, scrum master, and development team.\nProduct Owner: The person responsible for managing the developed product and maximizing its value. They ensure communication between the team and the management they are connected to but are not the manager of the team.\nScrum Master: The leader who serves the team, product owner, and organization. They ensure that the team understands and grasps the agile philosophy, coaches in developing high-value products, and helps remove obstacles in front of the team.\nDevelopment Team: A team consisting of test engineers, developers, and business analysts responsible for product development. It consists of individuals working with cross-functionality. The quality and responsibility of the product belong to the entire development team.\nIn Scrum processes, planning is divided into ‚Äúsprints.‚Äù A sprint is a project development cycle with a duration of 1 month or less. During the sprint, the focus is on the quality of the product, not just delivering a working product. Sprint durations are fixed; one sprint starts after another ends.\nSpecific meetings held within each sprint include:\nDaily Scrum: Held daily to share the tasks targeted to be completed within the day. By the end of the day, the targeted tasks are expected to be completed, ensuring the product development targeted at the end of the sprint.\nSprint Review: At the end of each sprint, a sprint review is held to share which tasks were completed and which tasks faced issues.\nSprint Planning: Tasks and their deadlines are pre-determined in a way suitable for the team. Sprint planning includes a product backlog and a sprint backlog. The product backlog contains every requirement for the product, while the sprint backlog includes only the parts to be worked on in that sprint.\nSprint Retrospective: After each sprint ends, a retrospective meeting is held. The purpose of the retrospective is to improve the team and teamwork. Various activities are also held to make the work more enjoyable for team members, and they make suggestions to each other.\nKanban Kanban is a method that progresses project processes based on visuality. (One of the differences from the Scrum methodology is that tasks are tracked via the Kanban Board.) The task load in Kanban can be adjusted according to the intensity of the team members. There are no defined role distributions in Kanban, but this can be changed. The entire team is responsible for product development. The team consists of self-coordinating individuals.\nIn the Kanban methodology, the process progresses through a Kanban Board as mentioned above. In office environments, we can see workflows on an actual board, but mostly task tracking is done via online tools like JIRA. Planning is done as follows:\nTo Do: Tasks to be done are listed here. These tasks are broken into small modules, and the time needed for each is pre-determined.\nIn Progress: Tasks that are in the development stage are listed here.\nTest: Tasks that have completed development and are ready for testing are listed here. After development, the environment should be stabilized for testing. Necessary data for testing should also be prepared. Otherwise, tests will be delayed, and there will be delays in delivering the product to the user.\nDone: Tasks that have successfully completed development and testing are listed here. After this point, the developed product is ready to be delivered to the user.\nWATERFALL MODEL The most common traditional software testing process is the waterfall process. In waterfall processes, start and end times are pre-determined and cannot be changed. Development is applied to the entire product, not just a part. The user communicates the desired product development at the beginning of the process and receives the output at the end, not being involved in the process. Waterfall processes proceed based on documentation, which facilitates the subsequent phases of projects. Project management is easier compared to Agile modeling.\nEveryone has a specific job description and cannot deviate from it. The role distribution is as follows:\nProject Manager: Responsible for the project\u0026rsquo;s objectives and how it will be carried out. Actively follows the project\u0026rsquo;s and process\u0026rsquo;s progress, ensuring the flow of information and removing obstacles in front of the team.\nAnalyst: Acts as a bridge between the user and the team developing the product. Analyzes the desired product development, prepares necessary documents, and conveys them to other teams.\nDeveloper: Designs and develops the product according to the specified requirements. Considering project constraints and the time needed, the best design is chosen for the product.\nTester: After the product development is completed, tests the product and its quality according to the specified requirements. Tests the product from the user\u0026rsquo;s perspective, communicates the errors to the development team, and rechecks the parts marked as resolved. Thus, ensures the product is delivered to the user in a healthy manner.\nIn the waterfall model, the process progresses as follows:\nPlanning: Planning is done first. The project\u0026rsquo;s purpose, output, and the duration of each phase are determined.\nAnalysis: After planning is completed, the project analysis is done. The details of the project are researched, and its needs are determined.\nDesign and Development: The project design is made. The architecture of the product is determined, and the design is chosen in the most suitable way for the project. Then, coding is done according to the chosen design.\nTest: After development is completed, it is checked whether the product works successfully as expected. This phase may require multiple tests, depending on the development done, such as unit testing, regression testing, and integration testing.\nDeployment and Maintenance: After successful completion of the tests, the product is put into use. At this step, product checks should continue even after delivery, and problems in the live environment should be quickly detected and resolved.\nSOURCES\nScrum Kƒ±lavuzu ‚Äî Ken Schwaber ve Jeff Sutherland https://softwarehut.com/blog/it-project-management/waterfall-101 https://www.atlassian.com/agile/kanban Medium\n","permalink":"http://localhost:1313/blog/agile-and-waterfall/","summary":"Introduction One of the most used concepts in the software world is SDLC (Software Development Life Cycle). So, what is SDLC? Briefly, it is the processes that include the development, design, and testing of a product.\nUnderstanding software development processes is as important for a test engineer as test quality, types, and test tools. In this article, I tried to briefly convey the most common SDLC processes, Agile and Waterfall modeling.","title":"Agile and Waterfall Methods in Software World"},{"content":"Description Leading QA Automation at Checkout-Payment Team, ensuring reliable user transactions. Integrating and maintaining comprehensive test suites, bridging manual and automated testing to guarantee best product quality. Collaborating with cross-functional teams to align QA strategies with overall project goals, ensuring a unified approach to quality. Elevating product standards through rigorous UI, App, and API testing, driving enhancements across multiple platforms. Specialized in automation by using cutting-edge tools. Leveraging Cypress with JavaScript for UI and API automation, and Maestro for app testing. Managing CI/CD pipelines with Jenkins and ArgoCD for streamlined deployment. Projects Shopping Services Payment project CarParts Checkout-Payment projects ","permalink":"http://localhost:1313/experience/check24/","summary":"Description Leading QA Automation at Checkout-Payment Team, ensuring reliable user transactions. Integrating and maintaining comprehensive test suites, bridging manual and automated testing to guarantee best product quality. Collaborating with cross-functional teams to align QA strategies with overall project goals, ensuring a unified approach to quality. Elevating product standards through rigorous UI, App, and API testing, driving enhancements across multiple platforms. Specialized in automation by using cutting-edge tools. Leveraging Cypress with JavaScript for UI and API automation, and Maestro for app testing.","title":"QA Automation Manager"},{"content":"Description Analyzed and optimized mobile applications at Turkcell, ensuring a seamless user experience and high performance. Developed automation project at Garanti BBVA, focusing on web applications and API services, significantly improving testing efficiency. Mastered automation using WebDriver.io and Karate DSL frameworks, leveraging both JavaScript and TypeScript to create test scripts. Supported comprehensive functional and regression testing, ensuring the integrity of software updates and new features. Led and mentored a team of QA engineers, fostering collaboration and ensuring consistent, high-quality output across the project. Projects Turkcell \u0026lsquo;≈ûirketim\u0026rsquo; and \u0026lsquo;Dijital Operator\u0026rsquo; app projects (B2C) Garanti BBVA Legal Customer applications project (B2B) ","permalink":"http://localhost:1313/experience/testinium/","summary":"Description Analyzed and optimized mobile applications at Turkcell, ensuring a seamless user experience and high performance. Developed automation project at Garanti BBVA, focusing on web applications and API services, significantly improving testing efficiency. Mastered automation using WebDriver.io and Karate DSL frameworks, leveraging both JavaScript and TypeScript to create test scripts. Supported comprehensive functional and regression testing, ensuring the integrity of software updates and new features. Led and mentored a team of QA engineers, fostering collaboration and ensuring consistent, high-quality output across the project.","title":"Software Test Specialist"},{"content":"Description Analyzed, designed, and managed comprehensive testing processes for projects following the waterfall model, ensuring thorough coverage at each phase. Executed and supported a range of tests‚Äîincluding integration, functional, regression, and User Acceptance Testing to validate software quality and functionality. Identified, documented, and reported critical bugs, facilitating prompt resolution and maintaining high standards of product reliability. Projects \u0026lsquo;Bulut Depo/Netdisk Tekille≈ütirme\u0026rsquo; (Streamlined cloud operations by merging two separate systems into a unified platform, enhancing efficiency and user experience.) \u0026lsquo;Tek≈üifre TTG Merkezi Login Altyapƒ±\u0026rsquo; (Simplified telecom user authentication by consolidating multiple login credentials into a single, secure username and password system, improving customer convenience and security.) \u0026lsquo;TTVM ‚Äì Marketplace √ºzerinden Dijital/Bulut √úr√ºnleri Satƒ±≈üƒ±\u0026rsquo; (Enabled seamless sales and provisioning of telecom products through a new, integrated marketplace system, driving business growth and customer engagement.) \u0026lsquo;Oracle SOA Suite 12C Upgrade Project\u0026rsquo; (Ensured system integrity by validating and verifying middleware services following the upgrade to Oracle SOA Suite 12C.) \u0026lsquo;WTTX Project\u0026rsquo; (Expanded internet accessibility by deploying wireless and portable modems, providing flexible and reliable connectivity solutions.) ","permalink":"http://localhost:1313/experience/egemsoft/","summary":"Description Analyzed, designed, and managed comprehensive testing processes for projects following the waterfall model, ensuring thorough coverage at each phase. Executed and supported a range of tests‚Äîincluding integration, functional, regression, and User Acceptance Testing to validate software quality and functionality. Identified, documented, and reported critical bugs, facilitating prompt resolution and maintaining high standards of product reliability. Projects \u0026lsquo;Bulut Depo/Netdisk Tekille≈ütirme\u0026rsquo; (Streamlined cloud operations by merging two separate systems into a unified platform, enhancing efficiency and user experience.","title":"Software Test Engineer"}]